// MIT License
//
// Copyright 2017 Electric Imp
//
// SPDX-License-Identifier: MIT
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
// EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
// OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// This application is a part of ElectricImp Smart Refrigerator demo that
// integrates Electric Imp devices with GE Predix IoT platform.
// It shows the latest data (temperature/humidity/door status) and
// alerts from ElectricImp devices connected to Predix.
// Additionally it implements http-to-websocket proxy that receives HTTP 
// requests from ElectricImp Predix library and resends them to the 
// Predix Time Series service through WebSocket.

// required modules
const HTTP = require('http');
const HTTPS = require('https');
const FS = require('fs');
const URL = require('url');
const PATH = require('path');
const CHEERIO = require('cheerio');
const WS = require('ws');
const BASE_PATH = __dirname;

// type of assets created by SmartRefrigerator_Predix demo
const SMART_FRIDGE_ASSET_TYPE = "smart_fridge";
const TOKEN_RENEW_BEFORE_EXPIRY_MS = 60 * 1000;
// Response status codes generated by the application HTTP server
const HTTP_OK = 200;
const HTTP_BAD_REQUEST = 400;
const HTTP_NOT_FOUND = 404;

// Predix environment variables
var config = require('./predix_config');

// application data
var assets = {};
var accessToken = null;
var tokenRenewTime = null;

// ------------------------ RUNTIME ------------------------ //

startApp();

// -------------------- PRIVATE METHODS -------------------- //

// Starts the application:
//   - initializes required data
//   - starts HTTP server
function startApp() {
    if (!config.initializationError) {
        accessCheckPromise().then(
            (resolve) => queryAssets(
                             SMART_FRIDGE_ASSET_TYPE, 
                             (respBody) => setAssets(respBody),
                             logError),
            logError);
    }

    var server = createHttpServer();
    server.listen(process.env.VCAP_APP_PORT || 5000, function() {
        logMessage('Server started on port: ' + server.address().port);
    });
}

// Creates the application HTTP server
function createHttpServer() {
    return HTTP.createServer(function(request, response) {
        var path = URL.parse(request.url).pathname;
        if (path == '/ingest_data') {
            if (request.method != 'POST') {
                setJsonErrorResponse(response, HTTP_BAD_REQUEST, 'Wrong request method');
                return;
            }
            else {
                var body = [];
                request.on('data', (data) => body.push(data)).
                        on('end', () => processIngestData(request, Buffer.concat(body).toString(), response)).
                        on('error', (error) => setJsonErrorResponse(response, HTTP_BAD_REQUEST, error));
            }
        }
        else if (config.initializationError) {
            setErrorResponse(response, HTTP_BAD_REQUEST, config.initializationError);
        }
        else if (path == '/') {
            accessCheckPromise().then(
                (resolve) => queryAssets(
                                 SMART_FRIDGE_ASSET_TYPE, 
                                 (respBody) => setSuccessResponse(response, getAssetsPage(respBody)),
                                 (error) => setErrorResponse(response, HTTP_BAD_REQUEST, error)),
                (error) => setErrorResponse(response, HTTP_BAD_REQUEST, error)
            );
        }
        else if (path.includes('/images/')) {
            var stream = FS.createReadStream(PATH.join(BASE_PATH, path));
            stream.on('error', () => setErrorResponse(response, HTTP_NOT_FOUND, path + ' not found'));
            stream.pipe(response);
        }
        else {
            var asset = path.substring(1);
            if (asset in assets) {
                accessCheckPromise().then(
                    (resolve) => queryAssetTimeSeriesData(
                                     SMART_FRIDGE_ASSET_TYPE,
                                     asset,
                                     assets[asset],
                                     (respBody) => setSuccessResponse(response, getAssetDataPage(respBody)),
                                     (error) => setErrorResponse(response, HTTP_BAD_REQUEST, error)),
                    (error) => setErrorResponse(response, HTTP_BAD_REQUEST, error));
            }
            else {
                setErrorResponse(response, HTTP_NOT_FOUND, path + ' not found');
            }
        }
    });
}

// Implements http-to-websocket proxy. Receives HTTP requests from ElectricImp Predix 
// library and resends them to the Predix Time Series service through WebSocket.
function processIngestData(request, requestBody, response) {
    if ('predix-zone-id' in request.headers && 'authorization' in request.headers) {
        var wsHeaders = {
            'predix-zone-id' : request.headers['predix-zone-id'],
            'authorization' : request.headers['authorization'],
            'origin': config.uaaUrl
        };
        const ws = new WS(config.timeSeriesIngestUrl, { headers : wsHeaders });
        ws.on('open', function open() {
            try {
                ws.send(requestBody);
                ws.close();
                setJsonSuccessResponse(response, null);
            }
            catch (err) {
                ws.close();
                setJsonErrorResponse(response, HTTP_BAD_REQUEST, err);
            }
        });
        ws.on('error', err => setJsonErrorResponse(response, HTTP_BAD_REQUEST, err));
    }
    else {
        setJsonErrorResponse(response, HTTP_BAD_REQUEST, 'missing required headers');
    }
}

// Updates assets object by assets info received from Predix Asset service
function setAssets(assetsRespBody) {
    // assetsRespBody Predix format:
    // [
    //   {
    //     "deviceId": "23477680116",
    //     "deviceInfo": {
    //       "sensors": [ "temperature", "humidity", "door" ],
    //       "alerts": [ "DoorOpenAlert", "TemperatureAlert", "HumidityAlert" ]
    //       ...
    //     },
    //     ...
    //   }, ...
    // ]
    assets = {};
    for (let asset of assetsRespBody) {
        if ('deviceId' in asset && 'deviceInfo' in asset) {
            assets[asset.deviceId] = asset.deviceInfo;
        }
        else {
            logError('Unexpected response from Predix Assets service ' + JSON.stringify(asset));
        }
    }
}

// Queries custom assets from Predix IoT platform by assetType
function queryAssets(assetType, onSuccess, onError) {
    var options = {
        hostname: config.assetHostName,
        path: '/' + assetType,
        headers: createHeaders(config.assetZoneId)
    };
    sendAsyncRequest('GET', options, null, 
        (respBody) => onSuccess(respBody),
        (err) => onError(err));
}

// Returns Predix Time Series tag name in the format specified by ElectricImp Predix library
function getTimeSeriesTagName(assetType, assetId, dataName) {
    return assetType + '.' + assetId + '.' + dataName;
}

// Queries TimeSeries data corresponded to the specified asset
function queryAssetTimeSeriesData(assetType, assetId, assetInfo, onSuccess, onError) {
    var sensorsTags = [];
    for (let sensor of assetInfo.sensors) {
        sensorsTags.push({'name': getTimeSeriesTagName(assetType, assetId, sensor)});
    }
    var alertsTags = [];
    for (let alert of assetInfo.alerts) {
        alertsTags.push({
            'name' : getTimeSeriesTagName(assetType, assetId, alert),
            'order' : 'desc'
        });
    }
    Promise.all([queryTimeSeriesDataPromise('/v1/datapoints/latest', {'tags' : sensorsTags}, 'sensors'),
                 queryTimeSeriesDataPromise('/v1/datapoints', {'start' : '1h-ago', 'tags' : alertsTags}, 'alerts')]).then(
        (resolve) => { 
            resolve.push(JSON.stringify({'deviceId' : assetId}));
            onSuccess(resolve);
        },
        (error) => onError(error));
}

// Queries data from Predix Time Series service
function queryTimeSeriesDataPromise(localPath, reqBody, dataType) {
    return new Promise(function(resolve, reject) {
        var options = {
            hostname: config.timeSeriesQueryHostName,
            path: localPath,
            headers: createHeaders(config.timeSeriesZoneId)
        };
        sendAsyncRequest('POST', options, JSON.stringify(reqBody), 
            (respBody) => {
                // respBody Predix format:
                // {"tags" : [
                //   {
                //     "name" : "smart_fridge.23477680116.temperature",
                //     "results" : [{"values" : [[1489090429000,24.0126,3], ...],"attributes" : {}}],
                //     "stats" : {"rawCount" : 1}
                //   }, ...
                // ]}
                if (!('tags' in respBody)) {
                    reject("Unexpected response from Predix TimeSeries service");
                    return;
                }
                var data = {};
                for (let value of respBody.tags) {
                    if (!('name' in value && 'results' in value)) {
                        reject("Unexpected response from Predix TimeSeries service");
                        return;
                    }
                    if (value['results'].length > 0 && value['results'][0]['values'].length > 0) {
                        var dataName = value['name'];
                        dataName = dataName.substring(dataName.lastIndexOf('.') + 1);
                        var measurements = [];
                        for (let measurement of value['results'][0]['values']) {
                            measurements.push({'data' : measurement[1], 'ts' : measurement[0]});
                        }
                        data[dataName] = measurements;
                    }
                }
                var result = {};
                result[dataType] = data;
                resolve(JSON.stringify(result));
            },
            (err) => reject(err));
    });
}

// Returns the main demo HTML page content
function getAssetsPage(assetsRespBody) {
    setAssets(assetsRespBody);

    var source = FS.readFileSync(PATH.join(BASE_PATH, 'public/assets.html'));
    var $ = CHEERIO.load(source);
    var asset;
    var assetsList = $('#assetsList');
    var first = true;
    for (asset in assets) {
        if (first) {
            $('#sensors_data').attr('onclick', "window.location.href='/" + asset + "'");
            first = false;
        }
        assetsList.append('<option value="' + asset + '">' + asset + '</option>')
    }
    if (first) {
        $('#assets').attr('style', 'display:none');
        $('#no_assets').attr('style', '');
    }
    return $.html();
}

// Returns content of HTML page with specific asset information
function getAssetDataPage(data) {
    var source = FS.readFileSync(PATH.join(BASE_PATH, 'public/asset_data.html'));
    var $ = CHEERIO.load(source);

    for (let d of data) {
        var jsonData = JSON.parse(d);
        if ('deviceId' in jsonData) {
            $('#deviceId').html(jsonData['deviceId']);
        }
        if ('sensors' in jsonData) {
            var sensors = jsonData['sensors'];
            var sensorsContent = '';
            for (var key in sensors) {
                var measurements = sensors[key];
                if (measurements.length > 0) {
                    sensorsContent += '<tr>';
                    sensorsContent += '<td>' + key + '</td>';
                    sensorsContent += '<td>' + measurements[0].data + '</td>';
                    sensorsContent += '<td>measured at ' + new Date(measurements[0].ts).toUTCString() + '</td>';
                    sensorsContent += '</tr>';
                }
            }
            $('#sensors').html(sensorsContent);
        }
        if ('alerts' in jsonData) {
            var alerts = jsonData['alerts'];
            var alertsContent = '';
            var alertsExist = false;
            for (var key in alerts) {
                alertsExist = true;
                for (let measurement of alerts[key]) {
                    alertsContent += '<tr>';
                    alertsContent += '<td>' + new Date(measurement.ts).toUTCString() + ':</td>';
                    alertsContent += '<td>' + measurement.data + '</td>';
                    alertsContent += '</tr>';
                }
                alertsContent += '<tr class="gap"></tr>';
            }
            if (!alertsExist) {
                alertsContent += '<tr><td>No alerts</td></tr><tr class="gap"></tr>';
            }
            $('#alerts').html(alertsContent);
        }
    }
    return $.html();
}

// Creates HTTP headers for Predix Asset and Time Series services requests
function createHeaders(zoneId) {
    return {
        "Authorization" : "Bearer " + accessToken,
        "Predix-Zone-Id" : zoneId,
        "Content-Type" : "application/json"
    };
}

// Checks Predix UAA access token and recreates it if needed
function accessCheckPromise() {
    return new Promise(function(resolve, reject) {
        if (accessToken == null || tokenRenewTime < new Date().getTime()) {
            var auth = new Buffer(config.uaaClientId + ':' + config.uaaClientSecret).toString('base64');
            var options = {
                hostname: config.uaaHostName,
                path: '/oauth/token',
                headers: {
                    'Authorization': 'Basic ' + auth,
                    'Cache-Control': 'no-cache',
                    'Content-Type': 'application/x-www-form-urlencoded'
                }
            };
            var body = 'client_id=' + config.uaaClientId + '&grant_type=client_credentials';
            sendAsyncRequest('POST', options, body, 
                (respBody) => {
                    if ('access_token' in respBody && 'expires_in' in respBody) {
                        accessToken = respBody.access_token;
                        tokenRenewTime = new Date().getTime() + respBody.expires_in * 1000 -
                            TOKEN_RENEW_BEFORE_EXPIRY_MS;
                        resolve("Access token created successfully");
                    }
                    else {
                        reject("Unexpected response from Predix User Account and Authentication service");
                    }
                },
                (err) => reject(err)
            );
        }
        else {
            resolve("Access token is valid");
        }
    });
}

// Utility methods for HTTP request/responses
function sendAsyncRequest(method, options, reqBody, onSuccess, onError) {
    options.method = method;
    var request = HTTPS.request(options, (response) => {
        var statusCode = response.statusCode;
        var respBody = [];
        response.on('data', (data) => respBody.push(data));
        response.on('end', () => {
            if (statusCode >= 200 && statusCode < 300) {
                try {
                    onSuccess(JSON.parse(Buffer.concat(respBody).toString()));
                }
                catch (e) {
                    onError(e.message);
                }
            }
            else {
                onError('HTTP request failed with status ' + statusCode);
            }
        });
        response.on('error', (error) => {
            if (onError) {
                onError(error);
            }
        });
    });
    request.on('error', (error) => {
        if (onError) {
            onError(error);
        }
    });

    if (reqBody) {
        request.write(reqBody);
    }
    request.end();
}

function setJsonErrorResponse(response, statusCode, error) {
    setResponse(response, statusCode, 'application/json', JSON.stringify({ message : error }));
    logError(error);
}

function setErrorResponse(response, statusCode, error) {
    setResponse(response, statusCode, 'text/html', '<h1>ERROR</h1>' + error);
    logError(error);
}

function setResponse(response, statusCode, contentType, body) {
    response.writeHead(statusCode, {'Content-Type': contentType});
    if (body != null) {
        response.write(body);
    }
    response.end();
}

function setJsonSuccessResponse(response, body) {
    setResponse(response, HTTP_OK, 'application/json', body);
}

function setSuccessResponse(response, body) {
    setResponse(response, HTTP_OK, 'text/html', body);
}

// Utility logging methods
function logError(error) {
    console.error(error);
}

function logMessage(message) {
    console.log(message);
}

